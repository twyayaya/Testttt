import numpy as np
import math
#
import torch
import torchvision
import torchvision.transforms as transforms
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
#


a = np.array([
    [1, 2, 3, 4, 5],
    [4, 5, 6, 7, 4],
    [7, 8, 9, 10, 3],
    [1, 2, 3, 4, 2],
    [4, 3, 2, 1, 1]

])
print(a.shape)


def pool(a, b):
    out_size = int(a.shape[0]/2)  # 3
    s = np.zeros((out_size, out_size))  # 3*3
    # print(s)
    z = laa(b)
    count = out_size-1  # 0 1 2
    for m in range(count):  # 列
        for n in range(count):  # 行
            y = lacd(a, b, m, n)  # 拉直a要被conv的部分
            s[m][n] = y.max()

    return j

#pool(a, z)


# print(a.max())
z = np.array([
    [2, 1],
    [2, 3],
])


def lacd(a, b, c, d):  # a:原本矩陣 b:weight c:a的c列 d:a的d行 ->把a拉成b矩陣內元素數的一列
    x = np.zeros((b.shape[0], b.shape[1]))
    for n in range(b.shape[0]):
        for k in range(b.shape[1]):
            x[n][k] = a[n+2*c][k+2*d]

    return x.reshape((1, b.size))


#l = lacd(a, z, 1, 2)
# print(l)
# print(l.max())

v = np.array([
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],
    [2, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],
    [3, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],
    [4, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],
    [5, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],
    [6, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],
    [7, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],
    [2, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],
    [3, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],
    [4, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],
    [5, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],
    [6, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],
    [7, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
])

print("v shape = ", v.shape)
b = np.array([
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
        17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    [2, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
        17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    [3, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
        17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    [4, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
        17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    [5, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
        17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    [6, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
        17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    [7, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
        17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    [8, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
        17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    [9, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
        17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    [10, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    [11, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    [12, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    [13, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    [14, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    [15, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    [16, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    [17, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    [18, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    [19, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    [20, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    [21, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    [22, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    [23, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    [24, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    [25, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    [26, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    [27, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    [28, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],

])
"""
print(b.shape)
print("----------")
b = torch.from_numpy(b)
print(b)
h = nn.MaxPool2d(2, 2)(F.relu(b))
print(h)
print("---------")
print("h shape = ", h.shape)
"""
## 一列n行轉開根號n*n矩陣, 前提是n能完整開根號

"""
def mntonn(a):
    print(a.shape[1])
    print(math.sqrt(a.shape[1]), type(math.sqrt(a.shape[1])))
    if math.sqrt(a.shape[1]).is_integer() == 1:
        s = int(math.sqrt(a.shape[1]))
        x = np.zeros((s, s))
        k = 0
        for m in range(s):
            for n in range(s):
                x[m][n] = a[0][k]
                k += 1
        return x
    else:
        print("wrong number")


kk = mntonn(v)

print(kk, type(kk))


# print("type = ", type(a))
# print(a.shape)
"""


def la(a, b, c, d):  # a:原本矩陣 b:weight c:a的c列 d:a的d行 ->把a拉成b矩陣內元素數的一列
    x = np.zeros((b.shape[0], b.shape[1]))
    for n in range(b.shape[0]):
        for k in range(b.shape[1]):
            x[n][k] = a[n+c][k+d]

    return x.reshape((1, b.size))


def laa(a):
    x = a.reshape((1, a.size))
    # print(x)
    return x


# conv


def convtest(a, b):  # a:input b:weight
    if a.size >= b.size:
        j_size = (a.shape[0] - b.shape[0] + 1)  # output長or寬 = 3
        j = np.zeros((j_size, j_size))  # output矩陣 = 3*3
        z = laa(b)  # 拉直b(weight)

        for m in range(j_size):  # 列
            # print("m = ", m)
            for n in range(j_size):  # 行
                # print("n = ", n)
                y = la(a, b, m, n)
            # print("y = ", y)  # 拉直a要被conv的部分
                for u in range(z.size):  # j矩陣內元素個數(j_size*j_size)
                    j[m][n] += y[0][u] * z[0][u]

        return j
    else:
        print("wrong number:a must >= b")


print("------------")
print("start\n")
kk = convtest(v, a)
print(kk)
print("kk.shape(must be 10*10 ) = ", kk.shape)


"""
start

[[27. 35. 43. 39.]
 [51. 59. 67. 47.]
 [30. 38. 46. 37.]
 [21. 19. 17. 15.]]

"""
"""
######test###

kk = convtest(a, z)
print("------------")
print(kk)

# maxpooling
maxn = kk.max()
print("kk = ", maxn)

"""


"""
b = np.zeros((2, 2))
for n in range(2):
    for k in range(2):
        b[n][k] = a[n][k+1]
print(b.reshape(1, 4))

-----------------------------
"""


def test():
    print("HELLO")
